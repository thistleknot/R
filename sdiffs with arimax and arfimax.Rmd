```{r}
#packages
{
packages <- c("dplyr","ggplot2","quantmod","zoo","plyr","forecast","tseries","tidyverse","furrr","reshape","lubridate","anytime","car","caret","ppcor","whitening","TSA","corrplot")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
}
```

```{r}
#data
raw <- read.csv("https://raw.githubusercontent.com/thistleknot/Python-Stock/master/data/combined_set.csv",row.names=1,header=TRUE)
```

```{r}
#functions
`%notin%` <- Negate(`%in%`)

PCOR <- function(x, type = c("raw", "cor")) {		 
		  type <- match.arg(type)
		  if (type == "raw") {		
			x <- scale(x)
			R <- (t(x) %*% x) / (nrow(x) - 1)
		  } else  {
			R <- x
		  }
		  
		  ind <- unique(dim(R))
		  R_inv <- ginv(R)
		  ZM <- matrix(rep(0, len = (ind*ind)), nrow = ind)
		  diag(ZM) <- diag(R_inv)
		  D <- ginv(ZM)
		  AICOV <- D %*% R_inv %*% D
		  diag(ZM) <- diag(AICOV)
		  D  <- ginv(sqrt(ZM))
		  AICOR <- D %*% AICOV %*% D
		  pcor <- AICOR
		  pcor[upper.tri(pcor)] <- -pcor[upper.tri(pcor)]
		  pcor[lower.tri(pcor)] <- -pcor[lower.tri(pcor)]
		  dimnames(pcor) <- list(colnames(R), colnames(R))
		  return(pcor)
		}  

critical.r <- function( n, alpha = .05 ) {
  df <- n - 2
  critical.t <- qt(alpha/2, df, lower.tail = F)
  critical.r <- sqrt( (critical.t^2) / ( (critical.t^2) + df ) )
  return(critical.r)
}

nv_diff_sets <- function(s,d,y,season=4,nv=NA)
{
  '
  d=1
  s=1
  y=raw[,"CSUSHPINSA",drop=FALSE]
  nv=c(6,7)
  '
  temp <- y
  
  set <- temp
  
  if(s==1)
  {
    
    #apply seasonal difference
    #temp <- as.data.frame(unlist(lapply((temp-dplyr::lag(temp,1*season)),function(x){ifelse(is.nan(x),return(0),return(x))})))
    temp <- temp-dplyr::lag(temp,1*season)
    
    colnames(temp) <- c("s")
    
    set <- cbind(set, temp)
  }
   
  for (d in 1:d)
  {#d=1
    
    temp <- temp-dplyr::lag(temp,1)
    colnames(temp) <- d
    set <- cbind(set, temp)
    
  }
  
  rownames(set) <- rownames(y)
  #extended <- c(temp_4,tail(c(c(temp_3),tail(temp_4,1)+cumsum(tail(temp_3,1)+cumsum(nv))),length(nv)))
 
  if (d==1&s==1)
  {
    temp3 <- dplyr::lag(set[,"s"],1)+set[,"1"]
    newSet <- dplyr::lag(set[,colnames(y)] ,season) + temp3
    
    ns_nt3 <- tail(set[,"s"],1)+cumsum(nv)
    extended <- head(tail(set[,colnames(y)],season),length(ns_nt3))+ns_nt3
    
  }else if (d==2&s==0) 
    {
    temp3 <- dplyr::lag(set[,"1"],1)+set[,"2"]
    #newSet <- (dplyr::lag(set[,1] ,1) + temp3)
    
    temp3[is.na(temp3)]=0
    cs <- cumsum(temp3)
    newSet <- set[1,1] + cs
    set <- cbind(set,temp3,cs,newSet)
    
    extended <- tail(set[,"cs"],1)+set[1,1]+cumsum(nv)
    
  } else if (d==1&s==0)
  {
    temp3 <- set[,"1"]
    
    temp3[is.na(temp3)]=0
    cs <- cumsum(temp3)
    newSet <- set[1,1] + cs
    set <- cbind(set,temp3,cs,newSet)
    
    extended <- tail(set[,"cs"],1)+set[1,1]+cumsum(nv)
    
    #newSet <- (dplyr::lag(set[,1] ,1) + temp3)
    
  }
  
  
  return(extended)
  
}


```

```{r}
#vars
f = periodicity(as.Date(anytime(rownames(raw))))

options("scipen"=100, "digits"=4)

season = switch(  
  f$scale,  
  "monthly"= 12,  
  "daily"= 252,  
  "quarterly"= 4,  
  "weekly"= 52,
)  

#plot(raw$GDPC1)
var_of_int <- "MSPUS"
#var_of_int <- "GDPC1"

```

```{r}
#differencing

sndif_ <- unlist(lapply(1:(length(colnames(raw))),function(n)
  {
    d_ <- nsdiffs(ts(raw[,n],frequency=season))
    return(d_)
  }))

combo_s <- do.call(cbind,lapply(1:length(sndif_), function(d)
  {
    if(sndif_[d]*season == 0)
    {
      temp <- raw[,d,drop=FALSE]
    }else
    {
      temp <- raw[,d,drop=FALSE]
      for(dif in 1:sndif_[d])
      {
        temp <- temp-dplyr::lag(temp,1*season)
      }
    }
  return(temp)
  }))

ndif_ <- c()

ndif_ <- unlist(lapply(1:(length(colnames(combo_s))),function(n)
{
  d_ <- ndiffs(combo_s[,n])
  #min 1 to ensure I'm being consistent (i.e. measuring rate of change between quarters). Note: ndiffs == na's return 0 so I handle na's in combo_d
  if(d_ == 0){d_ = 1}
  return(d_)
}))

combo_d <- do.call(cbind,lapply(1:length(ndif_),function(d)
{#no if check for 0 because at a minimum I want one difference
  temp <- combo_s[,d,drop=FALSE]
    for(dif in 1:ndif_[d])
    {
      temp <- as.data.frame(unlist(lapply((temp-dplyr::lag(temp,1)),function(x){ifelse(is.nan(x),return(0),return(x))})))
      colnames(temp) <- colnames(combo_s[,d,drop=FALSE])
      rownames(temp) <- rownames(combo_s[,d,drop=FALSE])
    }
    return(temp)
}))


which(((ndif_==2)*(sndif_==1))==1)

colnames(raw)[which(((ndif_==2)*(sndif_==0))==1)[1]]
colnames(raw)[which(((ndif_==1)*(sndif_==1))==1)[1]]
colnames(raw)[which(((ndif_==1)*(sndif_==0))==1)[1]]

colnames(raw$MSPUS)

#multiplicative (returns) to log

if(FALSE)
#CFNAIDIFF has negative initial values which make calculating returns impossible
{

  combo_s_m <- do.call(cbind,lapply(1:length(sndif_),function(d)
    {
      if(sndif_[d]*season == 0)
      {
        temp <- raw[,d,drop=FALSE]
      }else
      {
        temp <- raw[,d,drop=FALSE]
        for (sdif in 1:sndif_[d])
        {

          temp <- (1+((temp-dplyr::lag(temp,1*season))/dplyr::lag(temp,1*season)))
        }
      }
    return(temp)
    }))
  
  combo_d_m <- do.call(cbind,lapply(1:length(ndif_),function(d)
  {
    #d=1
      temp <- combo_s_m[,d,drop=FALSE]
      for (dif in 1:ndif_[d])
      {
        temp <- (1+((temp-dplyr::lag(temp,1))/dplyr::lag(temp,1)))
        
        temp <- as.data.frame(lapply(temp,function(x){ifelse(is.nan(x),return(0),return(x))}))
        rownames(temp) <- rownames(combo_s_m[,d,drop=FALSE])
      }
      return(temp)
  }))

}

```

```{r}
#optimal lagged correlation
# Example usage: Critical correlation coefficient at sample size of n = 100

names <- c()
lags <- c()
'
numZero <- colSums(combo_d == 0, na.rm = T)

numNaN <- sapply(combo_d_m, function(x) sum(is.nan(x)))

names(which(numNaN>0))

ndif_[which(colnames(raw)=="INTDSRUSM193N")]
sndif_[which(colnames(raw)=="INTDSRUSM193N")]

limit = (nrow(raw)/2)
drops = names(which(numZero>=limit))

#lapply(combo_d, function(x){ length(which(x==0))/length(x)})

combo_ <- na.omit(dplyr::select(combo_d, -c(drops)))
'
combo_ <- na.omit(combo_d)
{
  training <- combo_[1:floor(nrow(combo_)*.7),]
  #validation <- training-round(nrow(combo_)*.7*.3,0)
  holdout <- combo_[(nrow(training)+1):nrow(combo_),]
}
  
for(c in 1:(length(colnames(training))))
{#c=3
  
  ccf1 <- ccf(training[,var_of_int,drop=FALSE],training[,c], lag.max = season, correlation=TRUE, plot=FALSE)
  
  upperCI <- qnorm((1+0.95)/2)/sqrt(ccf1$n.used)
  lowerCI <- -qnorm((1+0.95)/2)/sqrt(ccf1$n.used)
  
  ind.max <- which(abs(ccf1$acf)==max(abs(ccf1$acf)))
  max.cor <- ccf1$acf[ind.max]
  lag.opt <- ccf1$lag[ind.max] 
  
  if(max.cor>critical.r( ccf1$n.used ))
  {
    
    if(lag.opt>0)
    {
      names <- c(names,(colnames(training)[c]))
      print(colnames(training)[c])
      print(lag.opt)
      print(max.cor)
      lags <- c(lags,lag.opt)
      print(2 * (1 - pnorm(abs(max.cor), mean = 0, sd = 1/sqrt(ccf1$n.used))))
    }
    
  }
}

#lag example
#cor(na.omit(cbind(training[,var_of_int,],dplyr::lag(training[,"SHY"],2))))

```
```{r}
#filter

newDF <- combo_[,var_of_int,drop=FALSE]

for (n in 1:length(names))
{
  newDF <- cbind(newDF,dplyr::lag(combo_[,names[n],drop=FALSE],n=abs(lags[n])))
  
}

newDF_t <- na.omit(newDF[1:nrow(training),])
newDF_h <- na.omit(newDF[(nrow(training)+1):nrow(combo_),])

#cor(na.omit(newDF[,c("MSPUS","M1"),]))

sig_table = matrix(0, ncol=ncol(newDF_t))
colnames(sig_table) <- colnames(newDF_t)
signs_table = matrix(0, ncol=ncol(newDF_t))
colnames(signs_table) <- colnames(newDF_t)

p_threshold = .05

New_Names = colnames(newDF_t)[2:length(colnames(newDF_t))]
iteration=0

dat <- 1:10
n=length(dat)

#folds<-createTimeSlices(y=rownames(newDF_t),initialWindow = 20,horizon = 10)

#lapply(folds,length)

exclude <- c()

#crit <- critical.r(nrow(set_), .05)

max_pvalue = 1

subset = newDF_t[,c(colnames(newDF_t) %notin% c(exclude))]

subset_w <- cbind(subset[,var_of_int,drop=FALSE],as.data.frame(whiten(as.matrix(subset[,c(colnames(newDF_t) %notin% c(var_of_int))]), method=c("ZCA"))))

colnames(subset_w) <- colnames(subset)
rownames(subset_w) <- rownames(subset)

corrplot(cor(subset_w))

set_ = subset_w[,c(colnames(newDF_t) %notin% c(var_of_int))]

while(max_pvalue>=p_threshold)
{
  p_values  <- (2 * (1 - pnorm(abs(cor(subset_w)[,var_of_int,drop=FALSE]), mean = 0, sd = 1/sqrt(nrow(subset)))))
  #p_values  <- (2 * (1 - pnorm(abs(PCOR(subset)[,var_of_int,drop=FALSE]), mean = 0, sd = 1/sqrt(nrow(subset)))))
  
  #pcor(subset, method = c("spearman"))$p.value[,var_of_int,drop=FALSE]
  
  max_pname = rownames(p_values)[which.max(p_values)]
  max_pvalue = p_values[max_pname,]
  
  if (max_pvalue >= p_threshold)
  {
    print(max_pvalue)
    print(max_pname)
    temp <- dplyr::select(subset_w,-c(max_pname))
    temp_ <- cbind(subset_w[,var_of_int,drop=FALSE],as.data.frame(whiten(as.matrix(temp[,c(colnames(temp) %notin% c(var_of_int))]), method=c("ZCA"))))
      
  colnames(temp_) <- colnames(temp)
  rownames(temp_) <- rownames(temp)
  subset_w <- temp_

    
  }
}
  
winners = rownames(p_values)[rownames(p_values) %notin% c(var_of_int)]
sig_table = sig_table + as.integer(colnames(newDF_t) %in% winners)

#t_ <- t(pcor(subset[,c(var_of_int,winners)], method = c("spearman"))$estimate[,var_of_int,drop=FALSE])[,-1]

corrplot(cor(subset_w[,c(var_of_int,winners)]))
'
rownames(t_) <- rownames(signs_table)

temp_ <- merge(t(signs_table), t_, by=0,all.x=TRUE)
rownames(temp_) <- temp_$Row.names
signs_table_ = rowSums(temp_[,2:3],na.rm=TRUE)
signs_table_ = ifelse(signs_table_==0,0,ifelse(signs_table_<0,-1,1))
signs_table = signs_table_ + signs_table

keepers = winners #colnames(sig_table)[sig_table>=(length(folds$train)/2)]
'

as.data.frame(rbind(sndif_[which(match(colnames(raw),c(var_of_int,winners))>0)],ndif_[which(match(colnames(raw),c(var_of_int,winners))>0)]))

#min of 1
differences <- as.data.frame(rbind(c(1,lags[which(match(names,c(var_of_int,winners))>0)]),sndif_[which(match(colnames(raw),c(var_of_int,winners))>0)],ndif_[which(match(colnames(raw),c(var_of_int,winners))>0)]))

#cbind(names[which(match(names,c(var_of_int,winners))>0)],

#lags[which(match(colnames(raw),c(var_of_int,winners))>0)]
colnames(differences) <- c(var_of_int,winners)

rownames(differences) <- c("lags","season","nonseason")
print(differences)

for(h in c(var_of_int,winners))
{
  hist(subset[,h])
}

lm_raw <- lm(na.omit(newDF_t[,c(var_of_int,winners),drop=FALSE]))
#summary(lm_raw)

na.omit(newDF_t[,c(var_of_int,winners),drop=FALSE])

#some seasons
#na.omit(combo_d[,c(var_of_int,winners),drop=FALSE])

```

```{r}
#models

horizon = 5

f <- as.formula(paste(var_of_int, " ~."))

lm_ <- lm(f, data=na.omit(newDF_t[,c(var_of_int,winners)]))

#summary(lm_)

#checkresiduals(lm_$residuals)

actual <- newDF_h[1:horizon,var_of_int,drop=FALSE]

#straight arima of y
test_0 <- auto.arima(newDF_t[,var_of_int,drop=FALSE])

f_0 <- as.data.frame(forecast(test_0,h=horizon))

#arima of lm residuals
test_1 <- auto.arima(lm_$residuals)

f_1 <- as.data.frame(forecast(test_1,h=horizon))

f_1a <- f_1 + t(predict(lm_,newdata=newDF_h[1:horizon,winners,drop=FALSE]))

rownames(f_1a) <- rownames(actual)

#arfima of residuals
test_2 <- arfima(lm_$residuals)

f_2 <- as.data.frame(forecast(test_2,h=horizon))

f_2a <- f_2 + t(predict(lm_,newdata=newDF_h[1:horizon,winners,drop=FALSE]))

#arima exogenous
test_3 <- auto.arima(newDF_t[,var_of_int,drop=FALSE],xreg=lm_$residuals)

f_3_lm_r <- forecast(lm_, newDF_h[1:horizon,winners,drop=FALSE], h=horizon)

#test_4 <- arfima(newDF_t[,var_of_int,drop=FALSE],xreg=lm_$residuals,estim=c("mle"))

f_3a <- as.data.frame(forecast(test_3,h=horizon,xreg=f_3_lm_r$mean))

#lapply(c(2,3,4),function(x){f_3_lm_r[names(f_3_lm_r)[x]]})

#rownames(f_3a)

rownames(f_1a) <- rownames(actual)
rownames(f_2a) <- rownames(actual)
rownames(f_3a) <- rownames(actual)

e_f_1a <- mean(abs(f_1a$`Point Forecast`-t(actual)))
e_f_2a <- mean(abs(f_2a$`Point Forecast`-t(actual)))
e_f_3a <- mean(abs(f_3a$`Point Forecast`-t(actual)))

e_f_0 <- mean(abs(f_0$`Point Forecast`-t(actual)))

print(paste("error forecast 0:", e_f_0))

print(paste("error forecast 1:", e_f_1a))

print(paste("error forecast 2:", e_f_2a))

print(paste("error forecast 3:", e_f_3a))

test_ <- forecast(test_3,h=horizon,xreg=f_3_lm_r$mean)

differences

mean_ <- raw[rownames(newDF_t[nrow(newDF_t),var_of_int,drop=FALSE]),var_of_int]+cumsum(f_3a)[,1]
lower_ <- raw[rownames(newDF_t[nrow(newDF_t),var_of_int,drop=FALSE]),var_of_int]+cumsum(f_3a)[,4]
upper_ <- raw[rownames(newDF_t[nrow(newDF_t),var_of_int,drop=FALSE]),var_of_int]+cumsum(f_3a)[,5]
actual_ <- raw[rownames(actual),var_of_int,drop=FALSE]

df <- data.frame(time = anydate(rownames(newDF_t)[1:length(mean_)]), actual_, mean_,lower_,upper_)

df <- melt(df ,  id.vars = 'time', variable.name = 'series')

ggplot(df, aes(time,value)) + geom_line(aes(colour = series))


nv_diff_sets(sndif_[which(colnames(raw)==var_of_int)],ndif_[which(colnames(raw)==var_of_int)],raw[rownames(newDF_t),var_of_int,drop=FALSE],season,c(f_3a$`Point Forecast`))


```


```{r}


```
